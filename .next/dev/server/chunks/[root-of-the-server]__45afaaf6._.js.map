{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///Users/kirti.krishnan/Desktop/Projects/RTAA/rtaa/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\n\nif (!supabaseUrl) {\n  throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL in environment');\n}\nif (!supabaseServiceRoleKey) {\n  throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY in environment');\n}\n\n// Custom fetch with better error handling for Node.js and corporate proxies\nconst customFetch: typeof fetch = async (input, init) => {\n  try {\n    // For development: bypass SSL verification for corporate proxies\n    // In Node.js 20+, we need to handle self-signed certificates\n    const https = await import('https');\n    const agent = new https.Agent({\n      rejectUnauthorized: false, // Accept self-signed certificates\n    });\n\n    const response = await fetch(input, {\n      ...init,\n      // @ts-ignore - agent is valid for Node.js fetch\n      agent,\n      // @ts-ignore - keepalive may not be in types but is valid\n      keepalive: false,\n    });\n    return response;\n  } catch (error) {\n    console.error('Supabase fetch error:', error);\n    throw error;\n  }\n};\n\nexport const supabase = createClient(supabaseUrl, supabaseServiceRoleKey, {\n  auth: { persistSession: false },\n  global: {\n    headers: { 'x-rt-agent-assist': 'rtaa-demo' },\n    fetch: customFetch,\n  },\n});\n\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AACN,MAAM,yBAAyB,QAAQ,GAAG,CAAC,yBAAyB;AAEpE;;AAGA,IAAI,CAAC,wBAAwB;IAC3B,MAAM,IAAI,MAAM;AAClB;AAEA,4EAA4E;AAC5E,MAAM,cAA4B,OAAO,OAAO;IAC9C,IAAI;QACF,iEAAiE;QACjE,6DAA6D;QAC7D,MAAM,QAAQ;QACd,MAAM,QAAQ,IAAI,MAAM,KAAK,CAAC;YAC5B,oBAAoB;QACtB;QAEA,MAAM,WAAW,MAAM,MAAM,OAAO;YAClC,GAAG,IAAI;YACP,gDAAgD;YAChD;YACA,0DAA0D;YAC1D,WAAW;QACb;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,MAAM;IACR;AACF;AAEO,MAAM,WAAW,IAAA,yMAAY,EAAC,aAAa,wBAAwB;IACxE,MAAM;QAAE,gBAAgB;IAAM;IAC9B,QAAQ;QACN,SAAS;YAAE,qBAAqB;QAAY;QAC5C,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///Users/kirti.krishnan/Desktop/Projects/RTAA/rtaa/lib/intent.ts"],"sourcesContent":["/**\n * Intent Detection Library\n * Uses OpenAI API to detect customer intent from transcript chunks\n */\n\ninterface IntentResult {\n  intent: string;\n  confidence: number;\n}\n\ninterface OpenAIResponse {\n  choices: Array<{\n    message: {\n      content: string;\n    };\n  }>;\n}\n\n/**\n * Detect customer intent from transcript text using OpenAI\n * @param text - The transcript text to analyze\n * @param context - Optional previous transcript chunks for context\n * @returns Intent label and confidence score\n */\nexport async function detectIntent(\n  text: string,\n  context?: string[]\n): Promise<IntentResult> {\n  const apiKey = process.env.LLM_API_KEY;\n\n  if (!apiKey) {\n    console.warn('[intent] LLM_API_KEY not configured, returning unknown intent');\n    return { intent: 'unknown', confidence: 0 };\n  }\n\n  try {\n    // Build context window\n    const contextText = context && context.length > 0\n      ? `Previous context:\\n${context.join('\\n')}\\n\\nCurrent:`\n      : 'Current:';\n\n    const prompt = `You are an intent classifier for customer support calls. Given the transcript snippet below, output a concise 3-5 word intent label and a confidence score (0-1).\n\n${contextText}\n\"${text}\"\n\nRespond ONLY with valid JSON in this exact format:\n{\"intent\": \"intent_label\", \"confidence\": 0.0}\n\nCommon intents: reset_password, update_billing, plan_upgrade, account_inquiry, technical_support, cancel_service, payment_issue`;\n\n    console.info('[intent] Calling OpenAI API for intent detection');\n\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a customer support intent classifier. Always respond with valid JSON containing \"intent\" and \"confidence\" fields.',\n          },\n          {\n            role: 'user',\n            content: prompt,\n          },\n        ],\n        temperature: 0.3,\n        max_tokens: 100,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('[intent] OpenAI API error:', response.status, errorText);\n      return { intent: 'unknown', confidence: 0 };\n    }\n\n    const data: OpenAIResponse = await response.json();\n    const content = data.choices[0]?.message?.content;\n\n    if (!content) {\n      console.error('[intent] No content in OpenAI response');\n      return { intent: 'unknown', confidence: 0 };\n    }\n\n    // Parse JSON response\n    const result = JSON.parse(content.trim());\n\n    // Normalize intent\n    const normalizedIntent = normalizeIntent(result.intent);\n    const confidence = Math.max(0, Math.min(1, Number(result.confidence) || 0));\n\n    console.info('[intent] Detected intent:', { intent: normalizedIntent, confidence });\n\n    return {\n      intent: normalizedIntent,\n      confidence,\n    };\n  } catch (error: any) {\n    console.error('[intent] Error detecting intent:', error.message);\n    return { intent: 'unknown', confidence: 0 };\n  }\n}\n\n/**\n * Normalize intent string for consistency and KB query\n * @param str - Raw intent string\n * @returns Normalized intent string\n */\nexport function normalizeIntent(str: string): string {\n  if (!str) return 'unknown';\n\n  return str\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special chars except space and dash\n    .replace(/\\s+/g, '_') // Replace spaces with underscore\n    .replace(/-+/g, '_') // Replace dashes with underscore\n    .replace(/_+/g, '_') // Collapse multiple underscores\n    .substring(0, 50); // Limit length\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAqBM,eAAe,aACpB,IAAY,EACZ,OAAkB;IAElB,MAAM,SAAS,QAAQ,GAAG,CAAC,WAAW;IAEtC,IAAI,CAAC,QAAQ;QACX,QAAQ,IAAI,CAAC;QACb,OAAO;YAAE,QAAQ;YAAW,YAAY;QAAE;IAC5C;IAEA,IAAI;QACF,uBAAuB;QACvB,MAAM,cAAc,WAAW,QAAQ,MAAM,GAAG,IAC5C,CAAC,mBAAmB,EAAE,QAAQ,IAAI,CAAC,MAAM,YAAY,CAAC,GACtD;QAEJ,MAAM,SAAS,CAAC;;AAEpB,EAAE,YAAY;CACb,EAAE,KAAK;;;;;+HAKuH,CAAC;QAE5H,QAAQ,IAAI,CAAC;QAEb,MAAM,WAAW,MAAM,MAAM,8CAA8C;YACzE,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,iBAAiB,CAAC,OAAO,EAAE,QAAQ;YACrC;YACA,MAAM,KAAK,SAAS,CAAC;gBACnB,OAAO;gBACP,UAAU;oBACR;wBACE,MAAM;wBACN,SAAS;oBACX;oBACA;wBACE,MAAM;wBACN,SAAS;oBACX;iBACD;gBACD,aAAa;gBACb,YAAY;YACd;QACF;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,YAAY,MAAM,SAAS,IAAI;YACrC,QAAQ,KAAK,CAAC,8BAA8B,SAAS,MAAM,EAAE;YAC7D,OAAO;gBAAE,QAAQ;gBAAW,YAAY;YAAE;QAC5C;QAEA,MAAM,OAAuB,MAAM,SAAS,IAAI;QAChD,MAAM,UAAU,KAAK,OAAO,CAAC,EAAE,EAAE,SAAS;QAE1C,IAAI,CAAC,SAAS;YACZ,QAAQ,KAAK,CAAC;YACd,OAAO;gBAAE,QAAQ;gBAAW,YAAY;YAAE;QAC5C;QAEA,sBAAsB;QACtB,MAAM,SAAS,KAAK,KAAK,CAAC,QAAQ,IAAI;QAEtC,mBAAmB;QACnB,MAAM,mBAAmB,gBAAgB,OAAO,MAAM;QACtD,MAAM,aAAa,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,OAAO,OAAO,UAAU,KAAK;QAExE,QAAQ,IAAI,CAAC,6BAA6B;YAAE,QAAQ;YAAkB;QAAW;QAEjF,OAAO;YACL,QAAQ;YACR;QACF;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,oCAAoC,MAAM,OAAO;QAC/D,OAAO;YAAE,QAAQ;YAAW,YAAY;QAAE;IAC5C;AACF;AAOO,SAAS,gBAAgB,GAAW;IACzC,IAAI,CAAC,KAAK,OAAO;IAEjB,OAAO,IACJ,WAAW,GACX,IAAI,GACJ,OAAO,CAAC,aAAa,IAAI,6CAA6C;KACtE,OAAO,CAAC,QAAQ,KAAK,iCAAiC;KACtD,OAAO,CAAC,OAAO,KAAK,iCAAiC;KACrD,OAAO,CAAC,OAAO,KAAK,gCAAgC;KACpD,SAAS,CAAC,GAAG,KAAK,eAAe;AACtC","debugId":null}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["file:///Users/kirti.krishnan/Desktop/Projects/RTAA/rtaa/lib/realtime.ts"],"sourcesContent":["/**\n * Real-time event broadcasting module\n * Supports Server-Sent Events (SSE) for live transcript and intent updates\n *\n * In-memory pub/sub system with per-call subscriptions.\n */\n\nimport type { RealtimeEvent } from './types';\n\n/**\n * SSE client representation\n */\ninterface SseClientEntry {\n  id: string;\n  callId: string | null; // null = global subscription\n  res: any; // Node ServerResponse\n  createdAt: Date;\n}\n\n// In-memory store of active SSE connections\nconst clients = new Map<string, SseClientEntry>();\n\n// Keep-alive interval (send comment every 30s to prevent timeout)\nconst HEARTBEAT_INTERVAL_MS = 30000;\nlet heartbeatTimer: NodeJS.Timeout | null = null;\n\n/**\n * Generate unique client ID\n */\nfunction generateClientId(): string {\n  return `client_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Register an SSE client connection\n *\n * @param req - Request object (for cleanup listening)\n * @param res - Node ServerResponse for streaming\n * @param callId - Optional callId to subscribe to specific call (null = global)\n */\nexport function registerSseClient(req: any, res: any, callId: string | null = null): void {\n  const clientId = generateClientId();\n\n  console.info('[realtime] New SSE client connected', {\n    clientId,\n    callId: callId || 'global',\n    totalClients: clients.size + 1,\n  });\n\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache, no-transform');\n  res.setHeader('Connection', 'keep-alive');\n  res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering\n\n  // CORS for dev (restrict in production)\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n  // Flush headers immediately\n  if (res.flushHeaders) {\n    res.flushHeaders();\n  }\n\n  // Send initial connection event\n  sendEvent(res, {\n    type: 'transcript_line',\n    callId: callId || 'system',\n    text: `Connected to realtime stream (clientId: ${clientId})`,\n  });\n\n  // Store client\n  clients.set(clientId, {\n    id: clientId,\n    callId,\n    res,\n    createdAt: new Date(),\n  });\n\n  // Start heartbeat if not already running\n  startHeartbeat();\n\n  // Cleanup on disconnect\n  req.on('close', () => {\n    console.info('[realtime] SSE client disconnected', {\n      clientId,\n      callId: callId || 'global',\n      duration: `${Date.now() - clients.get(clientId)?.createdAt.getTime() || 0}ms`,\n    });\n    clients.delete(clientId);\n\n    // Stop heartbeat if no clients left\n    if (clients.size === 0) {\n      stopHeartbeat();\n    }\n  });\n\n  req.on('error', (err: Error) => {\n    console.error('[realtime] SSE client error', { clientId, error: err.message });\n    clients.delete(clientId);\n  });\n}\n\n/**\n * Send a single event to a response stream\n */\nfunction sendEvent(res: any, event: RealtimeEvent): void {\n  try {\n    // Format: event: <type>\\ndata: <json>\\n\\n\n    res.write(`event: ${event.type}\\n`);\n    res.write(`data: ${JSON.stringify(event)}\\n\\n`);\n  } catch (err) {\n    console.error('[realtime] Failed to send event', err);\n  }\n}\n\n/**\n * Broadcast an event to all matching clients\n *\n * @param event - Event to broadcast\n */\nexport function broadcastEvent(event: RealtimeEvent): void {\n  const targetCallId = event.callId;\n  let sentCount = 0;\n\n  for (const [clientId, client] of clients.entries()) {\n    // Send to global subscribers or matching callId subscribers\n    if (client.callId === null || client.callId === targetCallId) {\n      try {\n        sendEvent(client.res, event);\n        sentCount++;\n      } catch (err) {\n        console.error('[realtime] Failed to send to client', { clientId, error: err });\n        // Remove failed client\n        clients.delete(clientId);\n      }\n    }\n  }\n\n  console.info('[realtime] Broadcast event', {\n    type: event.type,\n    callId: targetCallId,\n    seq: event.seq,\n    recipients: sentCount,\n    totalClients: clients.size,\n  });\n}\n\n/**\n * Start heartbeat to keep connections alive\n */\nfunction startHeartbeat(): void {\n  if (heartbeatTimer) return; // Already running\n\n  heartbeatTimer = setInterval(() => {\n    const now = Date.now();\n    for (const [clientId, client] of clients.entries()) {\n      try {\n        // Send comment (ignored by EventSource but keeps connection alive)\n        client.res.write(`: heartbeat ${now}\\n\\n`);\n      } catch (err) {\n        console.warn('[realtime] Heartbeat failed for client', { clientId });\n        clients.delete(clientId);\n      }\n    }\n  }, HEARTBEAT_INTERVAL_MS);\n\n  console.info('[realtime] Heartbeat started');\n}\n\n/**\n * Stop heartbeat timer\n */\nfunction stopHeartbeat(): void {\n  if (heartbeatTimer) {\n    clearInterval(heartbeatTimer);\n    heartbeatTimer = null;\n    console.info('[realtime] Heartbeat stopped');\n  }\n}\n\n/**\n * Get current client count (for monitoring)\n */\nexport function getClientCount(): number {\n  return clients.size;\n}\n\n/**\n * Get clients by callId (for debugging)\n */\nexport function getClientsByCallId(callId: string): number {\n  let count = 0;\n  for (const client of clients.values()) {\n    if (client.callId === null || client.callId === callId) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Disconnect all clients (for shutdown)\n */\nexport function disconnectAllClients(): void {\n  console.info('[realtime] Disconnecting all clients', { count: clients.size });\n  for (const [clientId, client] of clients.entries()) {\n    try {\n      client.res.end();\n    } catch (err) {\n      // Ignore errors during shutdown\n    }\n  }\n  clients.clear();\n  stopHeartbeat();\n}\n\n/**\n * Placeholder for WebSocket support (not implemented in Phase 3)\n *\n * To implement:\n * - Use 'ws' package\n * - Mirror broadcastEvent logic for WS clients\n * - Handle WebSocket upgrade requests\n */\nexport function openWebSocketServer(server: any): void {\n  console.warn('[realtime] WebSocket support not implemented. Use SSE for now.');\n  // Future: Initialize ws.Server(server) and handle connections\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///Users/kirti.krishnan/Desktop/Projects/RTAA/rtaa/app/api/calls/ingest-transcript/route.ts"],"sourcesContent":["/**\n * Ingest Transcript API - Receives transcript chunks from the orchestrator.\n * Validates, logs, stores chunks, detects intent, and fetches KB articles.\n */\n\nimport { NextResponse } from 'next/server';\nimport { supabase } from '@/lib/supabase';\nimport { detectIntent } from '@/lib/intent';\nimport { broadcastEvent } from '@/lib/realtime';\n\ninterface IngestRequest {\n  callId: string;\n  seq: number;\n  ts: string;\n  text: string;\n}\n\nexport async function POST(req: Request) {\n  try {\n    const body: IngestRequest = await req.json();\n\n    // Validate required fields\n    if (!body.callId || body.seq === undefined || !body.ts || !body.text) {\n      return NextResponse.json(\n        { ok: false, error: 'Missing required fields: callId, seq, ts, text' },\n        { status: 400 }\n      );\n    }\n\n    console.info('[ingest-transcript] Received chunk', {\n      callId: body.callId,\n      seq: body.seq,\n      ts: body.ts,\n      textLength: body.text.length,\n    });\n\n    // Insert into Supabase ingest_events table\n    try {\n      const { data, error } = await supabase.from('ingest_events').insert({\n        call_id: body.callId,\n        seq: body.seq,\n        ts: body.ts,\n        text: body.text,\n        created_at: new Date().toISOString(),\n      }).select();\n\n      if (error) {\n        console.error('[ingest-transcript] Supabase insert error:', error);\n        // Don't fail the request, just log it\n        console.warn('[ingest-transcript] Continuing despite Supabase error');\n      } else {\n        console.info('[ingest-transcript] Stored in Supabase:', data);\n      }\n    } catch (supabaseErr) {\n      console.error('[ingest-transcript] Supabase error:', supabaseErr);\n      // Continue processing even if Supabase fails\n    }\n\n    // Phase 3: Broadcast transcript line to real-time listeners\n    try {\n      broadcastEvent({\n        type: 'transcript_line',\n        callId: body.callId,\n        seq: body.seq,\n        ts: body.ts,\n        text: body.text,\n      });\n      console.info('[realtime] Broadcast transcript_line', {\n        callId: body.callId,\n        seq: body.seq,\n        textLength: body.text.length,\n      });\n    } catch (broadcastErr) {\n      console.error('[realtime] Failed to broadcast transcript_line:', broadcastErr);\n      // Don't fail the request\n    }\n\n    // Phase 2: Intent detection and KB article recommendations\n    let intent = 'unknown';\n    let confidence = 0.0;\n    let articles: Array<{ id: string; title: string; snippet: string; url: string }> = [];\n\n    try {\n      // Detect intent from the transcript text\n      console.info('[ingest-transcript] Detecting intent for seq:', body.seq);\n      const intentResult = await detectIntent(body.text);\n      intent = intentResult.intent;\n      confidence = intentResult.confidence;\n\n      console.info('[ingest-transcript] Intent detected:', { intent, confidence });\n\n      // Store intent in database\n      try {\n        const { error: intentError } = await supabase.from('intents').insert({\n          call_id: body.callId,\n          seq: body.seq,\n          intent,\n          confidence,\n          created_at: new Date().toISOString(),\n        });\n\n        if (intentError) {\n          console.error('[ingest-transcript] Failed to store intent:', intentError);\n        } else {\n          console.info('[ingest-transcript] Intent stored in database');\n        }\n      } catch (intentDbErr) {\n        console.error('[ingest-transcript] Intent DB error:', intentDbErr);\n      }\n\n      // Fetch relevant KB articles based on intent\n      if (intent && intent !== 'unknown') {\n        try {\n          console.info('[ingest-transcript] Fetching KB articles for intent:', intent);\n\n          const kbUrl = `http://localhost:3000/api/kb/search?query=${encodeURIComponent(intent)}`;\n          const kbResponse = await fetch(kbUrl);\n\n          if (kbResponse.ok) {\n            const kbData = await kbResponse.json();\n            if (kbData.ok && kbData.results) {\n              articles = kbData.results.slice(0, 3); // Top 3 articles\n              console.info('[ingest-transcript] Found KB articles:', articles.length);\n            }\n          } else {\n            console.warn('[ingest-transcript] KB search failed:', kbResponse.status);\n          }\n        } catch (kbErr) {\n          console.error('[ingest-transcript] KB fetch error:', kbErr);\n          // Continue without articles\n        }\n      }\n\n      // Phase 3: Broadcast intent update to real-time listeners\n      try {\n        broadcastEvent({\n          type: 'intent_update',\n          callId: body.callId,\n          seq: body.seq,\n          intent,\n          confidence,\n          articles,\n        });\n        console.info('[realtime] Broadcast intent_update', {\n          callId: body.callId,\n          seq: body.seq,\n          intent,\n          confidence,\n          articlesCount: articles.length,\n        });\n      } catch (broadcastErr) {\n        console.error('[realtime] Failed to broadcast intent_update:', broadcastErr);\n        // Don't fail the request\n      }\n    } catch (intentErr) {\n      console.error('[ingest-transcript] Intent detection error:', intentErr);\n      // Fallback to unknown intent\n      intent = 'unknown';\n      confidence = 0.0;\n    }\n\n    return NextResponse.json({\n      ok: true,\n      intent,\n      confidence,\n      articles,\n    });\n  } catch (err: any) {\n    console.error('[ingest-transcript] Error:', err);\n    return NextResponse.json(\n      { ok: false, error: err.message || String(err) },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}