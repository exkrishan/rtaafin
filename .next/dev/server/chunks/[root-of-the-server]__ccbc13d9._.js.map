{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/kirti.krishnan/Desktop/Projects/RTAA/rtaa/lib/realtime.ts"],"sourcesContent":["/**\n * Real-time event broadcasting module\n * Supports Server-Sent Events (SSE) for live transcript and intent updates\n *\n * In-memory pub/sub system with per-call subscriptions.\n */\n\nimport type { RealtimeEvent } from './types';\n\n/**\n * SSE client representation\n */\ninterface SseClientEntry {\n  id: string;\n  callId: string | null; // null = global subscription\n  res: any; // Node ServerResponse\n  createdAt: Date;\n}\n\n// In-memory store of active SSE connections\nconst clients = new Map<string, SseClientEntry>();\n\n// Keep-alive interval (send comment every 30s to prevent timeout)\nconst HEARTBEAT_INTERVAL_MS = 30000;\nlet heartbeatTimer: NodeJS.Timeout | null = null;\n\n/**\n * Generate unique client ID\n */\nfunction generateClientId(): string {\n  return `client_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Register an SSE client connection\n *\n * @param req - Request object (for cleanup listening)\n * @param res - Node ServerResponse for streaming\n * @param callId - Optional callId to subscribe to specific call (null = global)\n */\nexport function registerSseClient(req: any, res: any, callId: string | null = null): void {\n  const clientId = generateClientId();\n\n  console.info('[realtime] New SSE client connected', {\n    clientId,\n    callId: callId || 'global',\n    totalClients: clients.size + 1,\n  });\n\n  // Set SSE headers\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache, no-transform');\n  res.setHeader('Connection', 'keep-alive');\n  res.setHeader('X-Accel-Buffering', 'no'); // Disable nginx buffering\n\n  // CORS for dev (restrict in production)\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n  // Flush headers immediately\n  if (res.flushHeaders) {\n    res.flushHeaders();\n  }\n\n  // Send initial connection event\n  sendEvent(res, {\n    type: 'transcript_line',\n    callId: callId || 'system',\n    text: `Connected to realtime stream (clientId: ${clientId})`,\n  });\n\n  // Store client\n  clients.set(clientId, {\n    id: clientId,\n    callId,\n    res,\n    createdAt: new Date(),\n  });\n\n  // Start heartbeat if not already running\n  startHeartbeat();\n\n  // Cleanup on disconnect\n  req.on('close', () => {\n    console.info('[realtime] SSE client disconnected', {\n      clientId,\n      callId: callId || 'global',\n      duration: `${Date.now() - clients.get(clientId)?.createdAt.getTime() || 0}ms`,\n    });\n    clients.delete(clientId);\n\n    // Stop heartbeat if no clients left\n    if (clients.size === 0) {\n      stopHeartbeat();\n    }\n  });\n\n  req.on('error', (err: Error) => {\n    console.error('[realtime] SSE client error', { clientId, error: err.message });\n    clients.delete(clientId);\n  });\n}\n\n/**\n * Send a single event to a response stream\n */\nfunction sendEvent(res: any, event: RealtimeEvent): void {\n  try {\n    // Format: event: <type>\\ndata: <json>\\n\\n\n    res.write(`event: ${event.type}\\n`);\n    res.write(`data: ${JSON.stringify(event)}\\n\\n`);\n  } catch (err) {\n    console.error('[realtime] Failed to send event', err);\n  }\n}\n\n/**\n * Broadcast an event to all matching clients\n *\n * @param event - Event to broadcast\n */\nexport function broadcastEvent(event: RealtimeEvent): void {\n  const targetCallId = event.callId;\n  let sentCount = 0;\n\n  for (const [clientId, client] of clients.entries()) {\n    // Send to global subscribers or matching callId subscribers\n    if (client.callId === null || client.callId === targetCallId) {\n      try {\n        sendEvent(client.res, event);\n        sentCount++;\n      } catch (err) {\n        console.error('[realtime] Failed to send to client', { clientId, error: err });\n        // Remove failed client\n        clients.delete(clientId);\n      }\n    }\n  }\n\n  console.info('[realtime] Broadcast event', {\n    type: event.type,\n    callId: targetCallId,\n    seq: event.seq,\n    recipients: sentCount,\n    totalClients: clients.size,\n  });\n}\n\n/**\n * Start heartbeat to keep connections alive\n */\nfunction startHeartbeat(): void {\n  if (heartbeatTimer) return; // Already running\n\n  heartbeatTimer = setInterval(() => {\n    const now = Date.now();\n    for (const [clientId, client] of clients.entries()) {\n      try {\n        // Send comment (ignored by EventSource but keeps connection alive)\n        client.res.write(`: heartbeat ${now}\\n\\n`);\n      } catch (err) {\n        console.warn('[realtime] Heartbeat failed for client', { clientId });\n        clients.delete(clientId);\n      }\n    }\n  }, HEARTBEAT_INTERVAL_MS);\n\n  console.info('[realtime] Heartbeat started');\n}\n\n/**\n * Stop heartbeat timer\n */\nfunction stopHeartbeat(): void {\n  if (heartbeatTimer) {\n    clearInterval(heartbeatTimer);\n    heartbeatTimer = null;\n    console.info('[realtime] Heartbeat stopped');\n  }\n}\n\n/**\n * Get current client count (for monitoring)\n */\nexport function getClientCount(): number {\n  return clients.size;\n}\n\n/**\n * Get clients by callId (for debugging)\n */\nexport function getClientsByCallId(callId: string): number {\n  let count = 0;\n  for (const client of clients.values()) {\n    if (client.callId === null || client.callId === callId) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/**\n * Disconnect all clients (for shutdown)\n */\nexport function disconnectAllClients(): void {\n  console.info('[realtime] Disconnecting all clients', { count: clients.size });\n  for (const [clientId, client] of clients.entries()) {\n    try {\n      client.res.end();\n    } catch (err) {\n      // Ignore errors during shutdown\n    }\n  }\n  clients.clear();\n  stopHeartbeat();\n}\n\n/**\n * Placeholder for WebSocket support (not implemented in Phase 3)\n *\n * To implement:\n * - Use 'ws' package\n * - Mirror broadcastEvent logic for WS clients\n * - Handle WebSocket upgrade requests\n */\nexport function openWebSocketServer(server: any): void {\n  console.warn('[realtime] WebSocket support not implemented. Use SSE for now.');\n  // Future: Initialize ws.Server(server) and handle connections\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":["file:///Users/kirti.krishnan/Desktop/Projects/RTAA/rtaa/app/api/events/stream/route.ts"],"sourcesContent":["/**\n * SSE Stream Endpoint\n * GET /api/events/stream?callId=...\n *\n * Real-time event stream for transcript lines and intent updates.\n * Clients connect via EventSource and receive live events as they occur.\n *\n * Note: Must use Node.js runtime (not Edge) for response streaming support.\n */\n\n// Force Node runtime (Edge doesn't support streaming responses properly)\nexport const runtime = 'nodejs';\nexport const dynamic = 'force-dynamic';\n\nimport { registerSseClient } from '@/lib/realtime';\n\n/**\n * GET handler for SSE stream\n *\n * Query params:\n * - callId: Optional. Subscribe to specific call. Omit for global feed.\n */\nexport async function GET(req: Request) {\n  const url = new URL(req.url);\n  const callId = url.searchParams.get('callId') || null;\n\n  console.info('[sse-endpoint] New connection request', {\n    callId: callId || 'global',\n    userAgent: req.headers.get('user-agent')?.substring(0, 50),\n  });\n\n  // Create a TransformStream to handle SSE\n  const stream = new ReadableStream({\n    start(controller) {\n      // Create a mock response object that writes to the controller\n      const mockRes = {\n        setHeader: () => {},\n        flushHeaders: () => {},\n        write: (chunk: string) => {\n          try {\n            controller.enqueue(new TextEncoder().encode(chunk));\n          } catch (err) {\n            console.error('[sse-endpoint] Write error', err);\n          }\n        },\n        end: () => {\n          try {\n            controller.close();\n          } catch (err) {\n            // Already closed\n          }\n        },\n      };\n\n      // Create a mock request for cleanup handling\n      const mockReq = {\n        on: (event: string, handler: any) => {\n          if (event === 'close') {\n            // Store cleanup handler to call when stream is cancelled\n            return handler;\n          }\n        },\n      };\n\n      // Register SSE client\n      try {\n        registerSseClient(mockReq, mockRes, callId);\n      } catch (err) {\n        console.error('[sse-endpoint] Failed to register client', err);\n        controller.error(err);\n      }\n    },\n    cancel() {\n      console.info('[sse-endpoint] Stream cancelled', { callId: callId || 'global' });\n    },\n  });\n\n  // Return SSE response\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache, no-transform',\n      'Connection': 'keep-alive',\n      'X-Accel-Buffering': 'no',\n      // CORS for dev (restrict in production)\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type',\n    },\n  });\n}\n\n/**\n * OPTIONS handler for CORS preflight\n */\nexport async function OPTIONS() {\n  return new Response(null, {\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type',\n    },\n  });\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC,GAED,yEAAyE;;;;;;;;;;;AAIzE;AAHO,MAAM,UAAU;AAChB,MAAM,UAAU;;AAUhB,eAAe,IAAI,GAAY;IACpC,MAAM,MAAM,IAAI,IAAI,IAAI,GAAG;IAC3B,MAAM,SAAS,IAAI,YAAY,CAAC,GAAG,CAAC,aAAa;IAEjD,QAAQ,IAAI,CAAC,yCAAyC;QACpD,QAAQ,UAAU;QAClB,WAAW,IAAI,OAAO,CAAC,GAAG,CAAC,eAAe,UAAU,GAAG;IACzD;IAEA,yCAAyC;IACzC,MAAM,SAAS,IAAI,eAAe;QAChC,OAAM,UAAU;YACd,8DAA8D;YAC9D,MAAM,UAAU;gBACd,WAAW,KAAO;gBAClB,cAAc,KAAO;gBACrB,OAAO,CAAC;oBACN,IAAI;wBACF,WAAW,OAAO,CAAC,IAAI,cAAc,MAAM,CAAC;oBAC9C,EAAE,OAAO,KAAK;wBACZ,QAAQ,KAAK,CAAC,8BAA8B;oBAC9C;gBACF;gBACA,KAAK;oBACH,IAAI;wBACF,WAAW,KAAK;oBAClB,EAAE,OAAO,KAAK;oBACZ,iBAAiB;oBACnB;gBACF;YACF;YAEA,6CAA6C;YAC7C,MAAM,UAAU;gBACd,IAAI,CAAC,OAAe;oBAClB,IAAI,UAAU,SAAS;wBACrB,yDAAyD;wBACzD,OAAO;oBACT;gBACF;YACF;YAEA,sBAAsB;YACtB,IAAI;gBACF,IAAA,sIAAiB,EAAC,SAAS,SAAS;YACtC,EAAE,OAAO,KAAK;gBACZ,QAAQ,KAAK,CAAC,4CAA4C;gBAC1D,WAAW,KAAK,CAAC;YACnB;QACF;QACA;YACE,QAAQ,IAAI,CAAC,mCAAmC;gBAAE,QAAQ,UAAU;YAAS;QAC/E;IACF;IAEA,sBAAsB;IACtB,OAAO,IAAI,SAAS,QAAQ;QAC1B,SAAS;YACP,gBAAgB;YAChB,iBAAiB;YACjB,cAAc;YACd,qBAAqB;YACrB,wCAAwC;YACxC,+BAA+B;YAC/B,gCAAgC;YAChC,gCAAgC;QAClC;IACF;AACF;AAKO,eAAe;IACpB,OAAO,IAAI,SAAS,MAAM;QACxB,SAAS;YACP,+BAA+B;YAC/B,gCAAgC;YAChC,gCAAgC;QAClC;IACF;AACF","debugId":null}}]
}